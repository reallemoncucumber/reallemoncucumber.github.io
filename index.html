<!doctype html>
<html lang="en-us">

<head>
    <title>whisper.cpp : WASM example with Phaser.js</title>

    <style>
        #output {
            width: 100%;
            height: 200px;
            margin: 0 auto;
            margin-top: 10px;
            border-left: 0px;
            border-right: 0px;
            padding-left: 0px;
            padding-right: 0px;
            display: block;
            background-color: black;
            color: white;
            font-size: 10px;
            font-family: 'Lucida Console', Monaco, monospace;
            outline: none;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: scroll;
        }

        #recording-status {
            font-weight: bold;
            font-size: 14px;
            padding: 5px;
            border-radius: 3px;
            background-color: #f0f0f0;
            display: inline-block;
            margin-left: 10px;
        }

        #game-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        body {
            outline: none;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <script src="enable-threads.js"></script>
    <link rel="icon" href="data:,">
</head>

<body tabindex="0">
    <div id="main-container">
        <b>Minimal <a href="https://github.com/ggerganov/whisper.cpp">whisper.cpp</a> example with Phaser.js visualization</b>

        <br><br>

        Usage instructions:<br>
        <ul>
            <li>The tiny.en model will load automatically (31 MB)</li>
            <li>Hold SPACEBAR to record and auto-transcribe</li>
            <li>Transcribed text will appear in the center of the canvas below</li>
            <li>Text resets with each new recording</li>
        </ul>

        Note that the computation is quite heavy and may take a few seconds to complete.<br><br>
        <b>Important:</b>
        <ul>
            <li>your browser must support WASM SIMD instructions for this to work</li>
            <li>Firefox cannot load files larger than 256 MB - use Chrome instead</li>
            <li>When using microphone: hold SPACEBAR to record, release to stop</li>
        </ul>

        <hr>

        <div id="model">
            Model: <span id="model-whisper-status">Loading tiny.en model...</span><br>
            <span id="fetch-whisper-progress"></span>
        </div>

        <br>

        <div id="input_mic">
            Microphone: <span id="recording-status">Hold SPACEBAR to record</span>

            <br><br>
            <div id="progress" style="display: none;">
                <div id="progress-bar" style="width: 0%; height: 10px; background-color: #4CAF50;"></div>
                <div id="progress-text">0%</div>
            </div>
        </div>

        <hr><br>

        <div id="game-container"></div>

        <table>
            <tr>
                <td>
                    Language:
                    <select id="language" name="language">
                        <option value="en" selected>English</option>
                        <option value="ar">Arabic</option>
                        <option value="hy">Armenian</option>
                        <option value="az">Azerbaijani</option>
                        <option value="eu">Basque</option>
                        <option value="be">Belarusian</option>
                        <option value="bn">Bengali</option>
                        <option value="bg">Bulgarian</option>
                        <option value="ca">Catalan</option>
                        <option value="zh">Chinese</option>
                        <option value="hr">Croatian</option>
                        <option value="cs">Czech</option>
                        <option value="da">Danish</option>
                        <option value="nl">Dutch</option>
                        <option value="et">Estonian</option>
                        <option value="tl">Filipino</option>
                        <option value="fi">Finnish</option>
                        <option value="fr">French</option>
                        <option value="gl">Galician</option>
                        <option value="ka">Georgian</option>
                        <option value="de">German</option>
                        <option value="el">Greek</option>
                        <option value="gu">Gujarati</option>
                        <option value="iw">Hebrew</option>
                        <option value="hi">Hindi</option>
                        <option value="hu">Hungarian</option>
                        <option value="is">Icelandic</option>
                        <option value="id">Indonesian</option>
                        <option value="ga">Irish</option>
                        <option value="it">Italian</option>
                        <option value="ja">Japanese</option>
                        <option value="kn">Kannada</option>
                        <option value="ko">Korean</option>
                        <option value="la">Latin</option>
                        <option value="lv">Latvian</option>
                        <option value="lt">Lithuanian</option>
                        <option value="mk">Macedonian</option>
                        <option value="ms">Malay</option>
                        <option value="mt">Maltese</option>
                        <option value="no">Norwegian</option>
                        <option value="fa">Persian</option>
                        <option value="pl">Polish</option>
                        <option value="pt">Portuguese</option>
                        <option value="ro">Romanian</option>
                        <option value="ru">Russian</option>
                        <option value="sr">Serbian</option>
                        <option value="sk">Slovak</option>
                        <option value="sl">Slovenian</option>
                        <option value="es">Spanish</option>
                        <option value="sw">Swahili</option>
                        <option value="sv">Swedish</option>
                        <option value="ta">Tamil</option>
                        <option value="te">Telugu</option>
                        <option value="th">Thai</option>
                        <option value="tr">Turkish</option>
                        <option value="uk">Ukrainian</option>
                        <option value="ur">Urdu</option>
                        <option value="vi">Vietnamese</option>
                        <option value="cy">Welsh</option>
                        <option value="yi">Yiddish</option>
                    </select>
                </td>
                <td>
                    Threads:
                    <input type="range" id="threads" name="threads" min="1" max="16" value="8"
                        onchange="changeThreads(this.value)" />
                    <span id="threads-value">8</span>
                </td>
                <td>
                    <button onclick="onProcess();">Transcribe</button>
                </td>
            </tr>
        </table>

        <br>

        <textarea id="output" rows="10"></textarea>

        <br><br>

        <div class="cell-version">
            <span>
                |
                Build time: <span class="nav-link">Tue Aug 12 10:58:52 2025</span> |
                Commit hash: <a class="nav-link"
                    href="https://github.com/ggerganov/whisper.cpp/commit/5527454c">5527454c</a> |
                Commit subject: <span class="nav-link">whisper : fixed crash in GPU device selection on multi-GPU
                    systems (#3372)</span> |
                <a class="nav-link"
                    href="https://github.com/ggerganov/whisper.cpp/tree/master/examples/whisper.wasm">Source Code</a> |
            </span>
        </div>
    </div>

    <script type="text/javascript" src="helpers.js"></script>
    <script type='text/javascript'>
        var game;
        var transcriptionText;
        var currentTranscription = '';

        class TranscriptionScene extends Phaser.Scene {
            constructor() {
                super({ key: 'TranscriptionScene' });
            }

            preload() {
            }

            create() {
                console.log('Phaser scene created');
                this.add.rectangle(400, 300, 800, 600, 0x000033);
                
                this.add.text(400, 50, 'Whisper.cpp Live Transcription', {
                    fontSize: '24px',
                    fill: '#ffffff',
                    fontFamily: 'Arial, sans-serif'
                }).setOrigin(0.5);

                this.add.text(400, 100, 'Hold SPACEBAR to record', {
                    fontSize: '16px',
                    fill: '#cccccc',
                    fontFamily: 'Arial, sans-serif'
                }).setOrigin(0.5);

                transcriptionText = this.add.text(400, 300, 'Ready to transcribe...', {
                    fontSize: '20px',
                    fill: '#00ff00',
                    fontFamily: 'Arial, sans-serif',
                    align: 'center',
                    wordWrap: { width: 750, useAdvancedWrap: true }
                }).setOrigin(0.5);

                console.log('Transcription text object created:', transcriptionText);

                this.recordingIndicator = this.add.circle(400, 550, 20, 0xff0000);
                this.recordingIndicator.setVisible(false);

                this.recordingText = this.add.text(400, 520, 'RECORDING', {
                    fontSize: '16px',
                    fill: '#ff0000',
                    fontFamily: 'Arial, sans-serif'
                }).setOrigin(0.5);
                this.recordingText.setVisible(false);

                // Test the transcription display
                window.testTranscription = function(text) {
                    updateTranscriptionDisplay(text || 'Test transcription text');
                };
            }

            update() {
                if (doRecording) {
                    this.recordingIndicator.setVisible(true);
                    this.recordingText.setVisible(true);
                    this.recordingIndicator.setScale(0.8 + Math.sin(this.time.now * 0.01) * 0.2);
                } else {
                    this.recordingIndicator.setVisible(false);
                    this.recordingText.setVisible(false);
                }
            }
        }

        function initPhaser() {
            const config = {
                type: Phaser.AUTO,
                width: 800,
                height: 600,
                parent: 'game-container',
                backgroundColor: '#000033',
                scene: TranscriptionScene
            };

            game = new Phaser.Game(config);
        }

        function cleanTranscriptionText(text) {
            // Remove timestamp prefix like [00:00:00.000 --> 00:00:02.000]
            return text.replace(/\[\d{2}:\d{2}:\d{2}\.\d{3}\s*-->\s*\d{2}:\d{2}:\d{2}\.\d{3}\]\s*/g, '').trim();
        }

        function updateTranscriptionDisplay(text) {
            console.log('Updating transcription display with:', text);
            const cleanedText = cleanTranscriptionText(text);
            console.log('Cleaned text:', cleanedText);
            currentTranscription = cleanedText;
            if (transcriptionText) {
                transcriptionText.setText(cleanedText);
                console.log('Transcription text updated in Phaser');
            } else {
                console.log('Warning: transcriptionText object not found');
            }
        }

        function clearTranscriptionDisplay() {
            console.log('Clearing transcription display');
            currentTranscription = '';
            if (transcriptionText) {
                transcriptionText.setText('');
            }
        }

        function setAudio(audio) {
        }

        var Module = {
            print: function(text) {
                printTextarea(text);
                
                // Check for various whisper output patterns
                if (text.includes('whisper returned:')) {
                    const transcribedText = text.replace(/.*whisper returned:\s*/, '').trim();
                    if (transcribedText && transcribedText !== 'undefined' && transcribedText !== '') {
                        updateTranscriptionDisplay(transcribedText);
                    }
                } else if (text.trim() && !text.includes('js:') && !text.includes('processing') && 
                          !text.includes('audio') && !text.includes('storeFS') && 
                          !text.includes('whisper initialized') && text.length > 10) {
                    // Fallback: if it's substantial text that doesn't look like debug output
                    updateTranscriptionDisplay(text.trim());
                }
            },
            printErr: printTextarea,
            setStatus: function (text) {
                printTextarea('js: ' + text);
            },
            monitorRunDependencies: function (left) {
            }
        };

        var context = null;
        var audio = null;
        var instance = null;
        var model_whisper = 'tiny-en-q5_1';

        function convertTypedArray(src, type) {
            var buffer = new ArrayBuffer(src.byteLength);
            var baseView = new src.constructor(buffer).set(src);
            return new type(buffer);
        }

        let dbVersion = 1
        let dbName = 'whisper.ggerganov.com';
        let indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB

        function storeFS(fname, buf) {
            try {
                Module.FS_unlink(fname);
            } catch (e) {
            }

            Module.FS_createDataFile("/", fname, buf, true, true);
            document.getElementById('model-whisper-status').innerHTML = 'loaded "' + model_whisper + '"!';
            printTextarea('storeFS: stored model: ' + fname + ' size: ' + buf.length);
            document.getElementById('model').innerHTML = 'Model loaded: ' + model_whisper;
        }

        function loadWhisperModel() {
            let url = 'https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-tiny.en-q5_1.bin';
            let dst = 'whisper.bin';
            let size_mb = 31;

            document.getElementById('model-whisper-status').innerHTML = 'loading model: ' + model_whisper;

            var cbProgress = function (p) {
                let el = document.getElementById('fetch-whisper-progress');
                el.innerHTML = Math.round(100 * p) + '%';
            };

            var cbCancel = function () {
                document.getElementById('model-whisper-status').innerHTML = 'failed to load model';
            };

            loadRemote(url, dst, size_mb, cbProgress, storeFS, cbCancel, printTextarea);
        }

        const kMaxAudio_s = 30 * 60;
        const kMaxRecording_s = 2 * 60;
        const kSampleRate = 16000;

        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        window.OfflineAudioContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;

        var mediaRecorder = null;
        var doRecording = false;
        var startTime = 0;
        var isSpacePressed = false;

        function startRecording() {
            if (doRecording) return;

            clearTranscriptionDisplay();

            if (!context) {
                context = new AudioContext({
                    sampleRate: kSampleRate,
                    channelCount: 1,
                    echoCancellation: false,
                    autoGainControl: true,
                    noiseSuppression: true,
                });
            }

            document.getElementById('recording-status').innerHTML = 'Recording...';
            document.getElementById('recording-status').style.color = '#ff4444';
            document.getElementById('progress').style.display = 'block';
            document.getElementById('progress-bar').style.width = '0%';
            document.getElementById('progress-text').innerHTML = '0%';

            doRecording = true;
            startTime = Date.now();

            var chunks = [];
            var stream = null;

            navigator.mediaDevices.getUserMedia({ audio: true, video: false })
                .then(function (s) {
                    stream = s;
                    mediaRecorder = new MediaRecorder(stream);
                    mediaRecorder.ondataavailable = function (e) {
                        chunks.push(e.data);
                    };
                    mediaRecorder.onstop = function (e) {
                        var blob = new Blob(chunks, { 'type': 'audio/ogg; codecs=opus' });
                        chunks = [];

                        document.getElementById('recording-status').innerHTML = 'Hold SPACEBAR to record';
                        document.getElementById('recording-status').style.color = '';
                        document.getElementById('progress').style.display = 'none';

                        var reader = new FileReader();
                        reader.onload = function (event) {
                            var buf = new Uint8Array(reader.result);

                            context.decodeAudioData(buf.buffer, function (audioBuffer) {
                                var offlineContext = new OfflineAudioContext(audioBuffer.numberOfChannels, audioBuffer.length, audioBuffer.sampleRate);
                                var source = offlineContext.createBufferSource();
                                source.buffer = audioBuffer;
                                source.connect(offlineContext.destination);
                                source.start(0);

                                offlineContext.startRendering().then(function (renderedBuffer) {
                                    audio = renderedBuffer.getChannelData(0);
                                    printTextarea('js: audio recorded, size: ' + audio.length);

                                    if (audio.length > kMaxRecording_s * kSampleRate) {
                                        audio = audio.slice(0, kMaxRecording_s * kSampleRate);
                                        printTextarea('js: truncated audio to first ' + kMaxRecording_s + ' seconds');
                                    }
                                    setAudio(audio);

                                    document.getElementById('recording-status').innerHTML = 'Transcribing...';
                                    document.getElementById('recording-status').style.color = '#4CAF50';

                                    setTimeout(function () {
                                        onProcess();

                                        setTimeout(function () {
                                            document.getElementById('recording-status').innerHTML = 'Hold SPACEBAR to record';
                                            document.getElementById('recording-status').style.color = '';
                                        }, 1000);
                                    }, 100);
                                });
                            }, function (e) {
                                printTextarea('js: error decoding audio: ' + e);
                                audio = null;
                                setAudio(audio);
                            });
                        }

                        reader.readAsArrayBuffer(blob);
                    };
                    mediaRecorder.start();
                })
                .catch(function (err) {
                    printTextarea('js: error getting audio stream: ' + err);
                    doRecording = false;
                    document.getElementById('recording-status').innerHTML = 'Error: ' + err.message;
                    document.getElementById('recording-status').style.color = '#ff4444';
                });

            var interval = setInterval(function () {
                if (!doRecording || !isSpacePressed) {
                    clearInterval(interval);
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                    if (stream) {
                        stream.getTracks().forEach(function (track) {
                            track.stop();
                        });
                    }
                    return;
                }

                var elapsed = (Date.now() - startTime) / 1000;
                document.getElementById('progress-bar').style.width = (100 * elapsed / kMaxRecording_s) + '%';
                document.getElementById('progress-text').innerHTML = elapsed.toFixed(1) + 's';

                if (elapsed >= kMaxRecording_s) {
                    printTextarea('js: recording stopped after ' + kMaxRecording_s + ' seconds');
                    stopRecording();
                }
            }, 100);

            printTextarea('js: recording ...');
        }

        function stopRecording() {
            if (!doRecording) return;
            doRecording = false;

            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        }

        document.addEventListener('keydown', function (event) {
            if (event.code === 'Space' && !isSpacePressed) {
                event.preventDefault();
                isSpacePressed = true;
                startRecording();
            }
        });

        document.addEventListener('keyup', function (event) {
            if (event.code === 'Space' && isSpacePressed) {
                event.preventDefault();
                isSpacePressed = false;
                stopRecording();
            }
        });

        var nthreads = 8;

        function changeThreads(value) {
            nthreads = parseInt(value, 10);
            document.getElementById('threads-value').innerHTML = nthreads;
        }

        function onProcess() {
            if (!instance) {
                instance = Module.init('whisper.bin');

                if (instance) {
                    printTextarea("js: whisper initialized, instance: " + instance);
                    document.getElementById('model').innerHTML = 'Model loaded: ' + model_whisper;
                }
            }

            if (!instance) {
                printTextarea("js: failed to initialize whisper");
                return;
            }

            if (!audio) {
                printTextarea("js: no audio data");
                return;
            }

            if (instance) {
                printTextarea('');
                printTextarea('js: processing - this might take a while ...');
                printTextarea('');

                setTimeout(function () {
                    var ret = Module.full_default(instance, audio, document.getElementById('language').value, nthreads, false);
                    console.log('js: full_default returned: ' + ret);
                    
                    if (ret) {
                        printTextarea("js: whisper returned: " + ret);
                        
                        // Direct update to Phaser display
                        if (typeof ret === 'string' && ret.trim() && ret !== 'undefined') {
                            updateTranscriptionDisplay(ret.trim());
                        }
                    } else {
                        updateTranscriptionDisplay("No transcription result");
                    }
                }, 100);
            }
        }

        window.addEventListener('load', function () {
            initPhaser();
            loadWhisperModel();
            document.body.focus();
        });
    </script>
    <script type="text/javascript" src="main.js"></script>
</body>

</html>