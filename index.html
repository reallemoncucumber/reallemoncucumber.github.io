<!doctype html>
<html lang="en-us">

<head>
    <title>whisper.cpp : WASM example</title>

    <style>
        #output {
            width: 100%;
            height: 100%;
            margin: 0 auto;
            margin-top: 10px;
            border-left: 0px;
            border-right: 0px;
            padding-left: 0px;
            padding-right: 0px;
            display: block;
            background-color: black;
            color: white;
            font-size: 10px;
            font-family: 'Lucida Console', Monaco, monospace;
            outline: none;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: scroll;
        }

        #recording-status {
            font-weight: bold;
            font-size: 14px;
            padding: 5px;
            border-radius: 3px;
            background-color: #f0f0f0;
            display: inline-block;
            margin-left: 10px;
        }

        body {
            outline: none;
        }
    </style>
    <script src="coi-serviceworker.js"></script>
    <link rel="icon" href="data:,">
</head>

<body tabindex="0">
    <div id="main-container">
        <b>Minimal <a href="https://github.com/ggerganov/whisper.cpp">whisper.cpp</a> example running fully in the
            browser</b>

        <br><br>

        Usage instructions:<br>
        <ul>
            <li>The tiny.en model will load automatically (31 MB)</li>
            <li>Select audio file and click "Transcribe", or hold SPACEBAR to record and auto-transcribe (sample: <a
                    href="https://whisper.ggerganov.com/jfk.wav">jfk.wav</a>)</li>
            <li>Microphone recordings will transcribe automatically when you release SPACEBAR</li>
        </ul>

        Note that the computation is quite heavy and may take a few seconds to complete.<br>
        The transcription results will be displayed in the text area below.<br><br>
        <b>Important:</b>
        <ul>
            <li>your browser must support WASM SIMD instructions for this to work</li>
            <li>Firefox cannot load files larger than 256 MB - use Chrome instead</li>
            <li>When using microphone: hold SPACEBAR to record, release to stop</li>
        </ul>

        <b>More examples:</b>
        <a href="bench.wasm/">bench</a> |
        <a href="stream.wasm">stream</a> |
        <a href="command.wasm/">command</a> |

        <hr>

        <div id="model">
            Model: <span id="model-whisper-status">Loading tiny.en model...</span><br>
            <span id="fetch-whisper-progress"></span>
        </div>

        <br>

        <div id="input">
            Input:
            <input type="radio" id="file" name="input" value="file" checked="checked" onchange="changeInput('file')" />
            <label for="file">File</label>
            <input type="radio" id="mic" name="input" value="mic" onchange="changeInput('mic')" /> <label
                for="mic">Microphone</label>
        </div>

        <br>

        <div id="input_file">
            Audio file:
            <input type="file" id="file" name="file" onchange="loadAudio(event)" />
        </div>

        <div id="input_mic" style="display: none;">
            Microphone: <span id="recording-status">Hold SPACEBAR to record</span>

            <br><br>
            <div id="progress" style="display: none;">
                <div id="progress-bar" style="width: 0%; height: 10px; background-color: #4CAF50;"></div>
                <div id="progress-text">0%</div>
            </div>
        </div>

        <audio controls="controls" id="audio" loop hidden>
            Your browser does not support the &lt;audio&gt; tag.
            <source id="source" src="" type="audio/wav" />
        </audio>

        <hr><br>

        <table>
            <tr>
                <td>
                    Language:
                    <select id="language" name="language">
                        <option value="en" selected>English</option>
                        <option value="ar">Arabic</option>
                        <option value="hy">Armenian</option>
                        <option value="az">Azerbaijani</option>
                        <option value="eu">Basque</option>
                        <option value="be">Belarusian</option>
                        <option value="bn">Bengali</option>
                        <option value="bg">Bulgarian</option>
                        <option value="ca">Catalan</option>
                        <option value="zh">Chinese</option>
                        <option value="hr">Croatian</option>
                        <option value="cs">Czech</option>
                        <option value="da">Danish</option>
                        <option value="nl">Dutch</option>
                        <option value="et">Estonian</option>
                        <option value="tl">Filipino</option>
                        <option value="fi">Finnish</option>
                        <option value="fr">French</option>
                        <option value="gl">Galician</option>
                        <option value="ka">Georgian</option>
                        <option value="de">German</option>
                        <option value="el">Greek</option>
                        <option value="gu">Gujarati</option>
                        <option value="iw">Hebrew</option>
                        <option value="hi">Hindi</option>
                        <option value="hu">Hungarian</option>
                        <option value="is">Icelandic</option>
                        <option value="id">Indonesian</option>
                        <option value="ga">Irish</option>
                        <option value="it">Italian</option>
                        <option value="ja">Japanese</option>
                        <option value="kn">Kannada</option>
                        <option value="ko">Korean</option>
                        <option value="la">Latin</option>
                        <option value="lv">Latvian</option>
                        <option value="lt">Lithuanian</option>
                        <option value="mk">Macedonian</option>
                        <option value="ms">Malay</option>
                        <option value="mt">Maltese</option>
                        <option value="no">Norwegian</option>
                        <option value="fa">Persian</option>
                        <option value="pl">Polish</option>
                        <option value="pt">Portuguese</option>
                        <option value="ro">Romanian</option>
                        <option value="ru">Russian</option>
                        <option value="sr">Serbian</option>
                        <option value="sk">Slovak</option>
                        <option value="sl">Slovenian</option>
                        <option value="es">Spanish</option>
                        <option value="sw">Swahili</option>
                        <option value="sv">Swedish</option>
                        <option value="ta">Tamil</option>
                        <option value="te">Telugu</option>
                        <option value="th">Thai</option>
                        <option value="tr">Turkish</option>
                        <option value="uk">Ukrainian</option>
                        <option value="ur">Urdu</option>
                        <option value="vi">Vietnamese</option>
                        <option value="cy">Welsh</option>
                        <option value="yi">Yiddish</option>
                    </select>
                </td>
                <td>
                    Threads:
                    <input type="range" id="threads" name="threads" min="1" max="16" value="8"
                        onchange="changeThreads(this.value)" />
                    <span id="threads-value">8</span>
                </td>
                <td>
                    <button onclick="onProcess();">Transcribe</button>
                </td>
            </tr>
        </table>

        <br>

        <textarea id="output" rows="20"></textarea>

        <br><br>

        <div class="cell-version">
            <span>
                |
                Build time: <span class="nav-link">Tue Aug 12 10:58:52 2025</span> |
                Commit hash: <a class="nav-link"
                    href="https://github.com/ggerganov/whisper.cpp/commit/5527454c">5527454c</a> |
                Commit subject: <span class="nav-link">whisper : fixed crash in GPU device selection on multi-GPU
                    systems (#3372)</span> |
                <a class="nav-link"
                    href="https://github.com/ggerganov/whisper.cpp/tree/master/examples/whisper.wasm">Source Code</a> |
            </span>
        </div>
    </div>

    <script type="text/javascript" src="helpers.js"></script>
    <script type='text/javascript'>
        function setAudio(audio) {
        }

        function changeInput(input) {
            if (input == 'file') {
                document.getElementById('input_file').style.display = 'block';
                document.getElementById('input_mic').style.display = 'none';
            } else {
                document.getElementById('input_file').style.display = 'none';
                document.getElementById('input_mic').style.display = 'block';
            }
        }

        var Module = {
            print: printTextarea,
            printErr: printTextarea,
            setStatus: function (text) {
                printTextarea('js: ' + text);
            },
            monitorRunDependencies: function (left) {
            }
        };

        var context = null;
        var audio = null;
        var instance = null;
        var model_whisper = 'tiny-en-q5_1';

        function convertTypedArray(src, type) {
            var buffer = new ArrayBuffer(src.byteLength);
            var baseView = new src.constructor(buffer).set(src);
            return new type(buffer);
        }

        let dbVersion = 1
        let dbName = 'whisper.ggerganov.com';
        let indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB

        function storeFS(fname, buf) {
            try {
                Module.FS_unlink(fname);
            } catch (e) {
            }

            Module.FS_createDataFile("/", fname, buf, true, true);
            document.getElementById('model-whisper-status').innerHTML = 'loaded "' + model_whisper + '"!';
            printTextarea('storeFS: stored model: ' + fname + ' size: ' + buf.length);
            document.getElementById('model').innerHTML = 'Model loaded: ' + model_whisper;
        }

        function loadWhisperModel() {
            let url = 'https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-tiny.en-q5_1.bin';
            let dst = 'whisper.bin';
            let size_mb = 31;

            document.getElementById('model-whisper-status').innerHTML = 'loading model: ' + model_whisper;

            var cbProgress = function (p) {
                let el = document.getElementById('fetch-whisper-progress');
                el.innerHTML = Math.round(100 * p) + '%';
            };

            var cbCancel = function () {
                document.getElementById('model-whisper-status').innerHTML = 'failed to load model';
            };

            loadRemote(url, dst, size_mb, cbProgress, storeFS, cbCancel, printTextarea);
        }

        const kMaxAudio_s = 30 * 60;
        const kMaxRecording_s = 2 * 60;
        const kSampleRate = 16000;

        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        window.OfflineAudioContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;

        function loadAudio(event) {
            if (!context) {
                context = new AudioContext({
                    sampleRate: kSampleRate,
                    channelCount: 1,
                    echoCancellation: false,
                    autoGainControl: true,
                    noiseSuppression: true,
                });
            }

            var file = event.target.files[0] || null;
            if (file == null) {
                return;
            }

            printTextarea('js: loading audio: ' + file.name + ', size: ' + file.size + ' bytes');
            printTextarea('js: please wait ...');

            var reader = new FileReader();
            reader.onload = function (event) {
                var buf = new Uint8Array(reader.result);

                context.decodeAudioData(buf.buffer, function (audioBuffer) {
                    var offlineContext = new OfflineAudioContext(audioBuffer.numberOfChannels, audioBuffer.length, audioBuffer.sampleRate);
                    var source = offlineContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(offlineContext.destination);
                    source.start(0);

                    offlineContext.startRendering().then(function (renderedBuffer) {
                        audio = renderedBuffer.getChannelData(0);
                        printTextarea('js: audio loaded, size: ' + audio.length);

                        if (audio.length > kMaxAudio_s * kSampleRate) {
                            audio = audio.slice(0, kMaxAudio_s * kSampleRate);
                            printTextarea('js: truncated audio to first ' + kMaxAudio_s + ' seconds');
                        }

                        setAudio(audio);
                    });
                }, function (e) {
                    printTextarea('js: error decoding audio: ' + e);
                    audio = null;
                    setAudio(audio);
                });
            }
            reader.readAsArrayBuffer(file);
        }

        var mediaRecorder = null;
        var doRecording = false;
        var startTime = 0;
        var isSpacePressed = false;

        function startRecording() {
            if (doRecording) return;

            if (!context) {
                context = new AudioContext({
                    sampleRate: kSampleRate,
                    channelCount: 1,
                    echoCancellation: false,
                    autoGainControl: true,
                    noiseSuppression: true,
                });
            }

            document.getElementById('recording-status').innerHTML = 'Recording...';
            document.getElementById('recording-status').style.color = '#ff4444';
            document.getElementById('progress').style.display = 'block';
            document.getElementById('progress-bar').style.width = '0%';
            document.getElementById('progress-text').innerHTML = '0%';

            doRecording = true;
            startTime = Date.now();

            var chunks = [];
            var stream = null;

            navigator.mediaDevices.getUserMedia({ audio: true, video: false })
                .then(function (s) {
                    stream = s;
                    mediaRecorder = new MediaRecorder(stream);
                    mediaRecorder.ondataavailable = function (e) {
                        chunks.push(e.data);
                    };
                    mediaRecorder.onstop = function (e) {
                        var blob = new Blob(chunks, { 'type': 'audio/ogg; codecs=opus' });
                        chunks = [];

                        document.getElementById('recording-status').innerHTML = 'Hold SPACEBAR to record';
                        document.getElementById('recording-status').style.color = '';
                        document.getElementById('progress').style.display = 'none';

                        var reader = new FileReader();
                        reader.onload = function (event) {
                            var buf = new Uint8Array(reader.result);

                            context.decodeAudioData(buf.buffer, function (audioBuffer) {
                                var offlineContext = new OfflineAudioContext(audioBuffer.numberOfChannels, audioBuffer.length, audioBuffer.sampleRate);
                                var source = offlineContext.createBufferSource();
                                source.buffer = audioBuffer;
                                source.connect(offlineContext.destination);
                                source.start(0);

                                offlineContext.startRendering().then(function (renderedBuffer) {
                                    audio = renderedBuffer.getChannelData(0);
                                    printTextarea('js: audio recorded, size: ' + audio.length);

                                    if (audio.length > kMaxRecording_s * kSampleRate) {
                                        audio = audio.slice(0, kMaxRecording_s * kSampleRate);
                                        printTextarea('js: truncated audio to first ' + kMaxRecording_s + ' seconds');
                                    }
                                    setAudio(audio);

                                    document.getElementById('recording-status').innerHTML = 'Transcribing...';
                                    document.getElementById('recording-status').style.color = '#4CAF50';

                                    setTimeout(function () {
                                        onProcess();

                                        setTimeout(function () {
                                            document.getElementById('recording-status').innerHTML = 'Hold SPACEBAR to record';
                                            document.getElementById('recording-status').style.color = '';
                                        }, 1000);
                                    }, 100);
                                });
                            }, function (e) {
                                printTextarea('js: error decoding audio: ' + e);
                                audio = null;
                                setAudio(audio);
                            });
                        }

                        reader.readAsArrayBuffer(blob);
                    };
                    mediaRecorder.start();
                })
                .catch(function (err) {
                    printTextarea('js: error getting audio stream: ' + err);
                    doRecording = false;
                    document.getElementById('recording-status').innerHTML = 'Error: ' + err.message;
                    document.getElementById('recording-status').style.color = '#ff4444';
                });

            var interval = setInterval(function () {
                if (!doRecording || !isSpacePressed) {
                    clearInterval(interval);
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                    if (stream) {
                        stream.getTracks().forEach(function (track) {
                            track.stop();
                        });
                    }
                    return;
                }

                var elapsed = (Date.now() - startTime) / 1000;
                document.getElementById('progress-bar').style.width = (100 * elapsed / kMaxRecording_s) + '%';
                document.getElementById('progress-text').innerHTML = elapsed.toFixed(1) + 's';

                if (elapsed >= kMaxRecording_s) {
                    printTextarea('js: recording stopped after ' + kMaxRecording_s + ' seconds');
                    stopRecording();
                }
            }, 100);

            printTextarea('js: recording ...');
        }

        function stopRecording() {
            if (!doRecording) return;
            doRecording = false;

            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        }

        document.addEventListener('keydown', function (event) {
            if (event.code === 'Space' && !isSpacePressed) {
                event.preventDefault();
                isSpacePressed = true;
                if (document.querySelector('input[name="input"]:checked').value === 'mic') {
                    startRecording();
                }
            }
        });

        document.addEventListener('keyup', function (event) {
            if (event.code === 'Space' && isSpacePressed) {
                event.preventDefault();
                isSpacePressed = false;
                stopRecording();
            }
        });

        var nthreads = 8;

        function changeThreads(value) {
            nthreads = parseInt(value, 10);
            document.getElementById('threads-value').innerHTML = nthreads;
        }

        function onProcess() {
            if (!instance) {
                instance = Module.init('whisper.bin');

                if (instance) {
                    printTextarea("js: whisper initialized, instance: " + instance);
                    document.getElementById('model').innerHTML = 'Model loaded: ' + model_whisper;
                }
            }

            if (!instance) {
                printTextarea("js: failed to initialize whisper");
                return;
            }

            if (!audio) {
                printTextarea("js: no audio data");
                return;
            }

            if (instance) {
                printTextarea('');
                printTextarea('js: processing - this might take a while ...');
                printTextarea('');

                setTimeout(function () {
                    var ret = Module.full_default(instance, audio, document.getElementById('language').value, nthreads, false);
                    console.log('js: full_default returned: ' + ret);
                    if (ret) {
                        printTextarea("js: whisper returned: " + ret);
                    }
                }, 100);
            }
        }

        window.addEventListener('load', function () {
            loadWhisperModel();
            document.body.focus();
        });
    </script>
    <script type="text/javascript" src="main.js"></script>
</body>

</html>